<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Flare Ultimate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cloud.umami.is/script.js" data-website-id="002eec8c-1146-476f-b378-2031028710a5"></script>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    
    * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }
    
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: 'Press Start 2P', cursive;
        background-color: #0f0f1a;
        color: #00fffc;
        touch-action: manipulation;
        height: 100vh;
        width: 100vw;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    
    #gameContainer {
        position: relative;
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
        aspect-ratio: 1/1;
    }
    
    #gameCanvas {
        display: block;
        background-color: #0f0f1a;
        width: 100%;
        height: 100%;
        touch-action: none;
    }
    
    .neon-text {
        text-shadow: 0 0 5px #00fffc, 0 0 10px #00fffc, 0 0 15px #00fffc;
    }
    
    .neon-border {
        box-shadow: 0 0 10px #00fffc, 0 0 20px #00fffc, inset 0 0 10px #00fffc;
        border: 2px solid #00fffc;
        border-radius: 8px;
    }
    
    .powerup-glow {
        animation: pulse 1.5s infinite alternate;
    }
    
    @keyframes pulse {
        0% { box-shadow: 0 0 5px var(--powerup-color); }
        100% { box-shadow: 0 0 20px var(--powerup-color), 0 0 30px var(--powerup-color); }
    }
    
    .game-over {
        animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
    }
    
    @keyframes shake {
        10%, 90% { transform: translate3d(-1px, 0, 0); }
        20%, 80% { transform: translate3d(2px, 0, 0); }
        30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
        40%, 60% { transform: translate3d(4px, 0, 0); }
    }
    
    button {
        cursor: pointer;
        outline: none;
        transition: all 0.2s ease;
    }
    
    button:hover {
        transform: scale(1.05);
    }
    
    /* Mobile-specific adjustments */
    @media (max-width: 768px) {
        h1 {
            font-size: 1.3rem;
            margin-bottom: 0.3rem;
        }
        
        #startButton, #restartButton, #menuButton {
            padding: 0.6rem 1.2rem;
            font-size: 0.7rem;
        }
        
        .instructions {
            font-size: 0.6rem;
            line-height: 1.4;
        }
    }
    
    /* Volume control */
    #volumeControl {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        background: rgba(0,0,0,0.7);
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 1px solid #00fffc;
        transition: opacity 0.2s ease;
    }
    
    #volumeControl:hover {
        opacity: 0.8;
    }
    
    #volumeControl.muted {
        opacity: 0.5;
    }
    
    #volumeSlider {
        position: absolute;
        top: 50px;
        right: 0;
        background: rgba(0,0,0,0.9);
        padding: 1rem;
        border-radius: 8px;
        border: 2px solid #00fffc;
        box-shadow: 0 0 10px #00fffc;
        display: none;
    }
    
    #volumeSlider.show {
        display: block;
    }
    
    #volumeSlider label {
        display: block;
        color: #00fffc;
        font-size: 0.7rem;
        margin-bottom: 0.5rem;
    }
    
    #volumeSlider input[type="range"] {
        width: 100%;
        margin-bottom: 1rem;
    }
</style>
</head>
<body>
    <div id="volumeControl" title="Toggle Sound">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="#00fffc">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path>
        </svg>
    </div>
    
    <div id="volumeSlider">
        <div class="flex flex-col space-y-3">
            <div>
                <label for="musicVolume" class="text-xs neon-text block mb-1">MUSIC</label>
                <input type="range" id="musicVolume" min="0" max="100" value="30" class="w-full">
            </div>
            <div>
                <label for="sfxVolume" class="text-xs neon-text block mb-1">SFX</label>
                <input type="range" id="sfxVolume" min="0" max="100" value="50" class="w-full">
            </div>
        </div>
    </div>

    <div id="gameContainer">
        <div class="relative">
            <canvas id="gameCanvas" class="w-full neon-border rounded-lg"></canvas>
           <br>
            <!-- Start Screen -->
            <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-80 neon-border rounded-lg">
                <h2 class="text-2xl md:text-3xl mb-4 neon-text">NEON FLARE</h2>
                <p class="text-sm md:text-base mb-6 text-center px-4">Dodge obstacles, collect power-ups,<br>and survive as long as you can!</p>
                <a href="fitur.html" class="relative px-4 py-2 bg-transparent neon-border neon-text hover:bg-blue-900 hover:bg-opacity-30 transition-all rounded-md">
  FITUR
  <span class="absolute top-0 right-0 -mt-1 -mr-1 w-3 h-3 bg-red-500 rounded-full border border-black animate-ping"></span>
  <span class="absolute top-0 right-0 -mt-1 -mr-1 w-3 h-3 bg-red-500 rounded-full border border-black"></span>
</a>
<br>
                <button id="startButton" class="px-8 py-3 bg-transparent neon-border neon-text hover:bg-blue-900 hover:bg-opacity-30 transition-all">
                    START GAME
                </button>
                <br>
                <div class="flex flex-col items-center text-center text-xs mb-4 mt-2">
  <label for="difficultySlider" class="neon-text mb-2">PIPE DIFFICULTY</label>
  <input type="range" id="difficultySlider" min="1" max="100" value="10" class="w-48">
  <span id="difficultyValue" class="mt-1 neon-text">10</span>
                </div>
                <br>
                <div class="mt-6 text-xs text-center instructions">
                    <p>TAP ANYWHERE or PRESS SPACE to flap</p>
                    <p class="mt-2">Collect <span class="text-purple-300">POWER-UPS</span> for special abilities</p>
                </div>
            </div>
            
            <!-- Game Over Screen -->
            <div id="gameOverScreen" class="absolute inset-0 hidden flex-col items-center justify-center bg-black bg-opacity-80 neon-border rounded-lg">
                <h2 class="text-2xl md:text-3xl mb-4 neon-text game-over">GAME OVER</h2>
                <p id="finalScore" class="text-xl mb-2">SCORE: 0</p>
                <p id="highScore" class="text-lg mb-6">HIGH SCORE: 0</p>
                <div class="flex flex-col md:flex-row space-y-3 md:space-y-0 md:space-x-4">
                    <br>
                    <br>
                    <button id="restartButton" class="px-6 py-2 bg-transparent neon-border neon-text hover:bg-green-900 hover:bg-opacity-30">
                        PLAY AGAIN
                    </button>
                    <button id="menuButton" class="px-6 py-2 bg-transparent neon-border neon-text hover:bg-blue-900 hover:bg-opacity-30">
                        MENU
                    </button>
                </div>
            </div>
            
            <!-- In-game UI -->
            <div id="gameUI" class="absolute top-2 left-2 hidden">
                <div class="flex items-center space-x-4">
                    <div class="text-sm md:text-lg neon-text">SCORE: <span id="scoreDisplay">0</span></div>
                    <div class="text-sm md:text-lg neon-text">HI: <span id="hiScoreDisplay">0</span></div>
                </div>
                <div id="powerupIndicator" class="mt-1 hidden">
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full powerup-glow mr-1" style="--powerup-color: #00fffc;"></div>
                        <span class="text-xs neon-text" id="powerupTimer">0s</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="mt-2 text-xs text-center text-gray-400 instructions">
            <p>TAP ANYWHERE or PRESS SPACE to control. Game gets harder over time!</p>
        </div>
    </div>

    <!-- Audio elements -->
    <audio id="bgMusic" loop>
        <source src="audio/music.m4a" type="audio/mpeg">
    </audio>
    <audio id="flapSound">
        <source src="audio/plap.m4a" type="audio/mpeg">
    </audio>
    <audio id="pointSound">
        <source src="audio/pop.m4a" type="audio/mpeg">
    </audio>
    <audio id="powerupSound">
        <source src="audio/pick.m4a" type="audio/mpeg">
    </audio>
    <audio id="gameOverSound">
        <source src="audio/mati.m4a" type="audio/mpeg">
    </audio>
    <audio id="buttonSound">
        <source src="audio/klick.m4a" type="audio/mpeg">
    </audio>
    <audio id="shieldSound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-magic-spell-shield-246.mp3" type="audio/mpeg">
    </audio>
    <audio id="speedSound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-fast-small-sweep-transition-166.mp3" type="audio/mpeg">
    </audio>
    <audio id="ghostSound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-creepy-horror-demon-laugh-365.mp3" type="audio/mpeg">
    </audio>
    <audio id="magnetSound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-positivie-notification-266.mp3" type="audio/mpeg">
    </audio>
    <audio id="slowmoSound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-slow-motion-water-splash-1023.mp3" type="audio/mpeg">
    </audio>
    <audio id="laserSound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-laser-weapon-shot-1681.mp3" type="audio/mpeg">
    </audio>
    <audio id="spikeSound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-short-explosion-1694.mp3" type="audio/mpeg">
    </audio>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Game elements
        const gameContainer = document.getElementById('gameContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const gameUI = document.getElementById('gameUI');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const hiScoreDisplay = document.getElementById('hiScoreDisplay');
        const finalScore = document.getElementById('finalScore');
        const highScore = document.getElementById('highScore');
        const powerupIndicator = document.getElementById('powerupIndicator');
        const powerupTimer = document.getElementById('powerupTimer');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const menuButton = document.getElementById('menuButton');
        const difficultySlider = document.getElementById('difficultySlider');
        const difficultyValue = document.getElementById('difficultyValue');
        difficultySlider.addEventListener('input', () => {
        difficultyValue.textContent = difficultySlider.value;
        });
        
        // Audio elements
        const bgMusic = document.getElementById('bgMusic');
        const flapSound = document.getElementById('flapSound');
        const pointSound = document.getElementById('pointSound');
        const powerupSound = document.getElementById('powerupSound');
        const gameOverSound = document.getElementById('gameOverSound');
        const buttonSound = document.getElementById('buttonSound');
        const shieldSound = document.getElementById('shieldSound');
        const speedSound = document.getElementById('speedSound');
        const ghostSound = document.getElementById('ghostSound');
        const magnetSound = document.getElementById('magnetSound');
        const slowmoSound = document.getElementById('slowmoSound');
        const laserSound = document.getElementById('laserSound');
        const spikeSound = document.getElementById('spikeSound');
        
        // Volume controls
        const volumeControl = document.getElementById('volumeControl');
        const volumeSlider = document.getElementById('volumeSlider');
        const musicVolume = document.getElementById('musicVolume');
        const sfxVolume = document.getElementById('sfxVolume');
        
        // Game variables
        let gameRunning = false;
        let score = 0;
        let hiScore = localStorage.getItem('neonFlareHiScore') || 0;
        let animationFrameId;
        let lastTime = 0;
        let gameSpeed = 2.6;
        let baseGameSpeed = 2.6;
        let gravity = 0.2;
        let bird;
        let pipes = [];
        let powerups = [];
        let obstacles = [];
        let particles = [];
        let powerupActive = false;
        let powerupEndTime = 0;
        let powerupType = '';
        let difficultyInterval = 4000;
        let lastDifficultyIncrease = 0;
        let pipeInterval = 1500;
        let lastPipeTime = 0;
        let powerupInterval = 8000;
        let lastPowerupTime = 0;
        let obstacleInterval = 20000;
        let lastObstacleTime = 0;
        let isMobile = /Mobi|Android/i.test(navigator.userAgent);
        let magnetRadius = 0;
        let slowmoFactor = 1;
        let backgroundOffset = 0;
        let screenShake = 0;
        let comboMultiplier = 1;
        let lastScoreTime = 0;
        let comboTimeout = 2000;
        let parallaxLayers = [];
        let musicVolumeLevel = 0.3;
        let sfxVolumeLevel = 0.5;
        let pipeTypesUnlocked = 5;

        // Enhanced POWERUPS with GODMODE
        const POWERUPS = {
            SPEED: {
                name: 'speed',
                color: '#00fffc',
                symbol: '⚡',
                duration: 6000,
                effect: function() {
                    gameSpeed *= 1.5;
                    bird.color = this.color;
                    playSound(speedSound);
                },
                deactivate: function() {
                    gameSpeed /= 1.5;
                },
                weight: 3
            },
            SHIELD: {
                name: 'shield',
                color: '#ff00ff',
                symbol: '🛡️',
                duration: 5000,
                effect: function() {
                    bird.color = this.color;
                    playSound(shieldSound);
                },
                deactivate: function() {},
                weight: 2
            },
            GHOST: {
                name: 'ghost',
                color: '#ffffff',
                symbol: '👻',
                duration: 4000,
                effect: function() {
                    bird.color = this.color;
                    playSound(ghostSound);
                },
                deactivate: function() {},
                weight: 2
            },
            MAGNET: {
                name: 'magnet',
                color: '#ffcc00',
                symbol: '🧲',
                duration: 6000,
                effect: function() {
                    bird.color = this.color;
                    magnetRadius = canvas.width * 0.3;
                    playSound(magnetSound);
                },
                deactivate: function() {
                    magnetRadius = 0;
                },
                weight: 2
            },
            SLOWMO: {
                name: 'slowmo',
                color: '#00ff99',
                symbol: '🐌',
                duration: 4000,
                effect: function() {
                    slowmoFactor = 0.6;
                    bird.color = this.color;
                    playSound(slowmoSound);
                },
                deactivate: function() {
                    slowmoFactor = 1;
                },
                weight: 1
            },
            GODMODE: {
                name: 'godmode',
                color: '#ff0000',
                symbol: '💀',
                duration: 7000,
                effect: function() {
                    gameSpeed *= 2;
                    bird.color = this.color;
                    playSound(powerupSound);
                },
                deactivate: function() {
                    gameSpeed /= 2;
                },
                weight: 4
            }
        };

        // Enhanced PIPE_TYPES with 7 special types
        const PIPE_TYPES = {
            NORMAL: {
                weight: 5,
                generate: function() {
                    const gap = 120 + Math.random() * 60;
                    const topHeight = 50 + Math.random() * (canvas.height - gap - 50);
                    return {
                        type: 'normal',
                        x: canvas.width,
                        width: 80,
                        topHeight: topHeight,
                        bottomHeight: canvas.height - topHeight - gap,
                        passed: false,
                        color: '#006666'
                    };
                }
            },
            SPIKY: {
                weight: 3,
                generate: function() {
                    const gap = 100 + Math.random() * 60;
                    const topHeight = 50 + Math.random() * (canvas.height - gap - 50);
                    return {
                        type: 'spiky',
                        x: canvas.width,
                        width: 80,
                        topHeight: topHeight,
                        bottomHeight: canvas.height - topHeight - gap,
                        passed: false,
                        color: '#990000',
                        spikeTimer: 0,
                        spikeInterval: 2000 + Math.random() * 2000
                    };
                }
            },
            LASER_GAP: {
                weight: 3,
                generate: function() {
                    const gap = 120 + Math.random() * 60;
                    const topHeight = 80 + Math.random() * (canvas.height - gap - 50);
                    return {
                        type: 'laser_gap',
                        x: canvas.width,
                        width: 80,
                        topHeight: topHeight,
                        bottomHeight: canvas.height - topHeight - gap,
                        passed: false,
                        color: '#0066cc',
                        laserActive: false,
                        laserTimer: 0,
                        laserInterval: 1500 + Math.random() * 1500
                    };
                }
            },
            CLOSING: {
                weight: 2,
                generate: function() {
                    const gap = 80 + Math.random() * 40;
                    const topHeight = 50 + Math.random() * (canvas.height - gap - 50);
                    return {
                        type: 'closing',
                        x: canvas.width,
                        width: 80,
                        topHeight: topHeight,
                        bottomHeight: canvas.height - topHeight - gap,
                        passed: false,
                        color: '#cc6600',
                        closing: true,
                        closeSpeed: 0.2 + Math.random() * 0.3,
                        originalGap: gap
                    };
                }
            },
            MOVING: {
                weight: 2,
                generate: function() {
                    const gap = 120 + Math.random() * 60;
                    const topHeight = 50 + Math.random() * (canvas.height - gap - 50);
                    return {
                        type: 'moving',
                        x: canvas.width,
                        width: 80,
                        topHeight: topHeight,
                        bottomHeight: canvas.height - topHeight - gap,
                        passed: false,
                        color: '#6600cc',
                        moveDirection: Math.random() < 0.5 ? 1 : -1,
                        moveSpeed: 1 + Math.random() * 0.5
                    };
                }
            },
            INVISIBLE: {
                weight: 1,
                generate: function() {
                    const gap = 140 + Math.random() * 60;
                    const topHeight = 50 + Math.random() * (canvas.height - gap - 50);
                    return {
                        type: 'invisible',
                        x: canvas.width,
                        width: 80,
                        topHeight: topHeight,
                        bottomHeight: canvas.height - topHeight - gap,
                        passed: false,
                        color: '#00cc66',
                        visible: false,
                        blinkTimer: 0,
                        blinkInterval: 500 + Math.random() * 1000
                    };
                }
            },
            REVERSE_GRAVITY: {
                weight: 1,
                generate: function() {
                    const gap = 120 + Math.random() * 60;
                    const topHeight = 50 + Math.random() * (canvas.height - gap - 50);
                    return {
                        type: 'reverse_gravity',
                        x: canvas.width,
                        width: 80,
                        topHeight: topHeight,
                        bottomHeight: canvas.height - topHeight - gap,
                        passed: false,
                        color: '#cc0066'
                    };
                }
            },
            WARP: {
                weight: 1,
                generate: function() {
                    const gap = 150 + Math.random() * 60;
                    const topHeight = 50 + Math.random() * (canvas.height - gap - 50);
                    return {
                        type: 'warp',
                        x: canvas.width,
                        width: 80,
                        topHeight: topHeight,
                        bottomHeight: canvas.height - topHeight - gap,
                        passed: false,
                        color: '#00cccc',
                        warpTimer: 0,
                        warpInterval: 1000 + Math.random() * 2000
                    };
                }
            }
        };

        // Initialize parallax background
        function initParallax() {
            parallaxLayers = [
                { speed: 0.2, color: '#0a0a15', size: 80, offset: 0 },
                { speed: 0.5, color: '#111122', size: 40, offset: 0 },
                { speed: 0.8, color: '#1a1a2e', size: 20, offset: 0 }
            ];
        }

        // Set canvas size
        function resizeCanvas() {
            const containerWidth = gameContainer.clientWidth;
            const containerHeight = gameContainer.clientHeight;
            
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            
            // Adjust game elements for mobile
            if (isMobile) {
                gameSpeed = 3;
                gravity = 0.2;
            }
            
            initParallax();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Volume control functions
        function updateVolumes() {
            musicVolumeLevel = musicVolume.value / 200;
            sfxVolumeLevel = sfxVolume.value / 200;
            
            bgMusic.volume = musicVolumeLevel;
        }

        musicVolume.addEventListener('input', updateVolumes);
        sfxVolume.addEventListener('input', updateVolumes);

        function playSound(sound, volumeMultiplier = 1) {
            sound.currentTime = 0;
            sound.volume = sfxVolumeLevel * volumeMultiplier;
            sound.play().catch(e => console.log("Sound play prevented"));
        }

        // Initialize game
        function initGame() {
            bird = {
                x: canvas.width / 4,
                y: canvas.height / 2,
                radius: Math.max(12, canvas.width / 40),
                velocity: 0,
                color: '#00fffc',
                trail: [],
                flapWing: 0,
                wingDirection: 1
            };
            
            pipes = [];
            powerups = [];
            obstacles = [];
            particles = [];
            score = 0;
            comboMultiplier = 1;
            gameSpeed = isMobile ? 2 : 2;
            baseGameSpeed = gameSpeed;
            gravity = isMobile ? 0.5 : 0.3;
            powerupActive = false;
            powerupType = '';
            lastPipeTime = 0;
            lastPowerupTime = 0;
            lastObstacleTime = 0;
            lastDifficultyIncrease = 0;
            magnetRadius = 0;
            slowmoFactor = 1;
            screenShake = 0;
            const sliderValue = parseInt(difficultySlider.value);
pipeTypesUnlocked = Math.ceil((sliderValue / 100) * 10);
pipeTypesUnlocked = Math.max(1, Math.min(pipeTypesUnlocked, 8)); // Start with only normal pipes
            
            scoreDisplay.textContent = score;
            hiScoreDisplay.textContent = hiScore;
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameUI.classList.remove('hidden');
            powerupIndicator.classList.add('hidden');
            
            // Start background music
            bgMusic.volume = musicVolumeLevel;
            bgMusic.currentTime = 0;
            bgMusic.play().catch(e => console.log("Autoplay prevented"));
            
            gameRunning = true;
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!gameRunning) return;
            
            const deltaTime = (timestamp - lastTime) * slowmoFactor;
            lastTime = timestamp;
            
            update(deltaTime);
            draw();
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Update game state
        function update(deltaTime) {
            // Update bird
            bird.velocity += gravity;
            bird.y += bird.velocity;
            
            // Bird wing animation
            bird.flapWing += 0.1 * bird.wingDirection;
            if (bird.flapWing > 1 || bird.flapWing < -1) {
                bird.wingDirection *= -1;
            }
            
            // Add current position to trail
            bird.trail.push({x: bird.x, y: bird.y});
            if (bird.trail.length > 10) {
                bird.trail.shift();
            }
            
            // Check for collisions with top/bottom
            if (bird.y - bird.radius < 0 || bird.y + bird.radius > canvas.height) {
                if (powerupActive && (powerupType === 'shield' || powerupType === 'ghost' || powerupType === 'godmode')) {
                    // Bounce off walls with shield or ghost
                    bird.velocity = -bird.velocity * 0.5;
                    bird.y = Math.max(bird.radius, Math.min(canvas.height - bird.radius, bird.y));
                    createParticles(bird.x, bird.y, 10, POWERUPS[powerupType.toUpperCase()].color);
                } else {
                    gameOver();
                    return;
                }
            }
            
            // Update pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                pipes[i].x -= gameSpeed * slowmoFactor;
                
                // Update special pipe behaviors
                switch(pipes[i].type) {
                    case 'spiky':
                        pipes[i].spikeTimer += deltaTime;
                        if (pipes[i].spikeTimer >= pipes[i].spikeInterval) {
                            pipes[i].spikeTimer = 0;
                            playSound(spikeSound, 0.3);
                        }
                        break;
                        
                    case 'laser_gap':
                        pipes[i].laserTimer += deltaTime;
                        if (pipes[i].laserTimer >= pipes[i].laserInterval) {
                            pipes[i].laserTimer = 1;
                            pipes[i].laserActive = !pipes[i].laserActive;
                            if (pipes[i].laserActive) playSound(laserSound, 0.2);
                        }
                        break;
                        
                    case 'closing':
                        if (pipes[i].closing) {
                            const closeAmount = pipes[i].closeSpeed * deltaTime * 0.3;
                            pipes[i].topHeight += closeAmount;
                            pipes[i].bottomHeight += closeAmount;
                            
                            // Check if pipe is completely closed
                            if (canvas.height - pipes[i].topHeight - pipes[i].bottomHeight <= 0) {
                                pipes.splice(i, 1);
                                continue;
                            }
                        }
                        break;
                        
                    case 'moving':
                        pipes[i].topHeight += pipes[i].moveSpeed * pipes[i].moveDirection;
                        pipes[i].bottomHeight = canvas.height - pipes[i].topHeight - 
                            (canvas.height - pipes[i].topHeight - pipes[i].bottomHeight);
                        
                        // Reverse direction if hitting top/bottom
                        if (pipes[i].topHeight < 50) {
                            pipes[i].topHeight = 50;
                            pipes[i].moveDirection *= -1;
                        } else if (pipes[i].topHeight > canvas.height - 50 - 
                                  (canvas.height - pipes[i].topHeight - pipes[i].bottomHeight)) {
                            pipes[i].topHeight = canvas.height - 50 - 
                                (canvas.height - pipes[i].topHeight - pipes[i].bottomHeight);
                            pipes[i].moveDirection *= -1;
                        }
                        break;
                        
                    case 'invisible':
                        pipes[i].blinkTimer += deltaTime;
                        if (pipes[i].blinkTimer >= pipes[i].blinkInterval) {
                            pipes[i].blinkTimer = 0;
                            pipes[i].visible = !pipes[i].visible;
                        }
                        break;
                        
                    case 'reverse_gravity':
                        if (bird.x > pipes[i].x && bird.x < pipes[i].x + pipes[i].width) {
                            gravity = -Math.abs(gravity);
                        }
                        break;
                        
                    case 'warp':
                        pipes[i].warpTimer += deltaTime;
                        if (pipes[i].warpTimer >= pipes[i].warpInterval) {
                            pipes[i].warpTimer = 0;
                            // Randomly warp the bird
                            if (bird.x > pipes[i].x && bird.x < pipes[i].x + pipes[i].width) {
                                bird.y = 50 + Math.random() * (canvas.height - 100);
                                createParticles(bird.x, bird.y, 20, '#00cccc');
                            }
                        }
                        break;
                }
                
                // Check for collision with bird
                if (
                    !(powerupActive && (powerupType === 'shield' || powerupType === 'ghost' || powerupType === 'godmode'|| powerupType === 'speed')) &&
                    bird.x + bird.radius > pipes[i].x && 
                    bird.x - bird.radius < pipes[i].x + pipes[i].width
                ) {
                    // Check top pipe collision
                    if (bird.y - bird.radius < pipes[i].topHeight) {
                        // Special collision checks
                        let collided = true;
                        
                        if (pipes[i].type === 'invisible' && !pipes[i].visible) {
                            collided = false;
                        }
                        
                        if (pipes[i].type === 'spiky' && pipes[i].spikeTimer < pipes[i].spikeInterval - 500) {
                            collided = false;
                        }
                        
                        if (collided) {
                            screenShake = 10;
                            gameOver();
                            return;
                        }
                    }
                    
                    // Check bottom pipe collision
                    if (bird.y + bird.radius > canvas.height - pipes[i].bottomHeight) {
                        let collided = true;
                        
                        if (pipes[i].type === 'invisible' && !pipes[i].visible) {
                            collided = false;
                        }
                        
                        if (pipes[i].type === 'spiky' && pipes[i].spikeTimer < pipes[i].spikeInterval - 500) {
                            collided = false;
                        }
                        
                        if (collided) {
                            screenShake = 10;
                            gameOver();
                            return;
                        }
                    }
                    
                    // Check laser gap collision
                    if (pipes[i].type === 'laser_gap' && pipes[i].laserActive) {
                        const gapCenter = pipes[i].topHeight + 
                            (canvas.height - pipes[i].topHeight - pipes[i].bottomHeight) / 2;
                        const laserHeight = 12;
                        
                        if (Math.abs(bird.y - gapCenter) < laserHeight / 2 + bird.radius) {
                            screenShake = 10;
                            gameOver();
                            return;
                        }
                    }
                }
                
                // Check if bird passed the pipe
                if (pipes[i].x + pipes[i].width < bird.x && !pipes[i].passed) {
                    pipes[i].passed = true;
                    
                    // Combo system
                    const now = performance.now();
                    if (now - lastScoreTime < comboTimeout) {
                        comboMultiplier = Math.min(5, comboMultiplier + 0.2);
                    } else {
                        comboMultiplier = 1;
                    }
                    lastScoreTime = now;
                    
                    score += comboMultiplier;
                    scoreDisplay.textContent = Math.floor(score);
                    playSound(pointSound, 0.2);
                    createParticles(pipes[i].x + pipes[i].width / 2, canvas.height / 2, 5 * comboMultiplier, '#00fffc');
                    
                    // Unlock new pipe types as score increases
                    if (score >= 5 && pipeTypesUnlocked < 2) pipeTypesUnlocked = 2;
                    if (score >= 10 && pipeTypesUnlocked < 3) pipeTypesUnlocked = 3;
                    if (score >= 20 && pipeTypesUnlocked < 4) pipeTypesUnlocked = 4;
                    if (score >= 30 && pipeTypesUnlocked < 5) pipeTypesUnlocked = 5;
                    if (score >= 40 && pipeTypesUnlocked < 6) pipeTypesUnlocked = 6;
                    if (score >= 50 && pipeTypesUnlocked < 7) pipeTypesUnlocked = 7;
                    if (score >= 60 && pipeTypesUnlocked < 8) pipeTypesUnlocked = 8;
                }
                
                // Remove pipes that are off screen
                if (pipes[i].x + pipes[i].width < 0) {
                    pipes.splice(i, 1);
                }
            }
            
            // Update powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                powerups[i].x -= gameSpeed * slowmoFactor;
                
                // Pulsing animation
                powerups[i].pulse = Math.sin(performance.now() * 0.005) * 2;
                
                // Magnet effect
                if (magnetRadius > 0) {
                    const distance = Math.sqrt(
                        Math.pow(bird.x - powerups[i].x, 2) + 
                        Math.pow(bird.y - powerups[i].y, 2)
                    );
                    
                    if (distance < magnetRadius) {
                        const angle = Math.atan2(
                            bird.y - powerups[i].y,
                            bird.x - powerups[i].x
                        );
                        
                        powerups[i].x += Math.cos(angle) * 5;
                        powerups[i].y += Math.sin(angle) * 5;
                    }
                }
                
                // Check for collision with bird
                if (
                    Math.sqrt(
                        Math.pow(bird.x - powerups[i].x, 2) + 
                        Math.pow(bird.y - powerups[i].y, 2)
                    ) < bird.radius + powerups[i].radius
                ) {
                    activatePowerup(powerups[i].type);
                    powerups.splice(i, 1);
                    continue;
                }
                
                // Remove powerups that are off screen
                if (powerups[i].x + powerups[i].radius < 0) {
                    powerups.splice(i, 1);
                }
            }
            
            // Update shooting lasers from right
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= gameSpeed * obstacles[i].speedFactor * slowmoFactor;
                
                if (obstacles[i].type === 'shooting_laser') {
                    // Check collision
                    if (
                        !(powerupActive && (powerupType === 'shield' || powerupType === 'ghost' || powerupType === 'godmode')) &&
                        bird.x + bird.radius > obstacles[i].x && 
                        bird.x - bird.radius < obstacles[i].x + obstacles[i].width &&
                        bird.y + bird.radius > obstacles[i].y && 
                        bird.y - bird.radius < obstacles[i].y + obstacles[i].height
                    ) {
                        screenShake = 15;
                        gameOver();
                        return;
                    }
                    
                    // Remove if off screen
                    if (obstacles[i].x + obstacles[i].width < 0) {
                        obstacles.splice(i, 1);
                        continue;
                    }
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx * slowmoFactor;
                particles[i].y += particles[i].vy * slowmoFactor;
                particles[i].life -= deltaTime;
                
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update parallax background
            backgroundOffset += gameSpeed * 0.5 * slowmoFactor;
            parallaxLayers.forEach(layer => {
                layer.offset = backgroundOffset * layer.speed;
            });
            
            // Update powerup timer
            if (powerupActive) {
                const remainingTime = Math.max(0, powerupEndTime - performance.now());
                powerupTimer.textContent = `${(remainingTime / 1000).toFixed(1)}s`;
                
                if (remainingTime <= 0) {
                    deactivatePowerup();
                }
            }
            
            // Update screen shake
            if (screenShake > 0) {
                screenShake -= 1;
            }
            
            // Generate new pipes
            if (performance.now() - lastPipeTime > pipeInterval / slowmoFactor) {
                generatePipe();
                lastPipeTime = performance.now();
                pipeInterval = Math.max(500, 1200 - score * 2 + Math.random() * 600);
            }
            
            // Generate powerups (not inside pipes)
            if (performance.now() - lastPowerupTime > powerupInterval / slowmoFactor && Math.random() < 0.7) {
                generatePowerup();
                lastPowerupTime = performance.now();
                powerupInterval = 5000 + Math.random() * 5000;
            }
            
            // Generate shooting lasers from right
            if (score >= 10 && performance.now() - lastObstacleTime > obstacleInterval / slowmoFactor && Math.random() < 0.5) {
                generateShootingLaser();
                lastObstacleTime = performance.now();
                obstacleInterval = Math.max(8000, 15000 - score * 150);
            }
            
            // Increase difficulty over time
            if (performance.now() - lastDifficultyIncrease > difficultyInterval / slowmoFactor) {
                increaseDifficulty();
                lastDifficultyIncrease = performance.now();
            }
            
            // Reset gravity if not in reverse gravity pipe
            let inReversePipe = false;
            for (const pipe of pipes) {
                if (pipe.type === 'reverse_gravity' && 
                    bird.x > pipe.x && bird.x < pipe.x + pipe.width) {
                    inReversePipe = true;
                    break;
                }
            }
            
            if (!inReversePipe) {
                gravity = isMobile ? 0.4 : 0.2;
                if (powerupActive && powerupType === 'reverse_gravity') {
                    gravity = -Math.abs(gravity);
                }
            }
        }

        // Draw everything
        function draw() {
            // Apply screen shake
            const shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            const shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            
            ctx.save();
            ctx.translate(shakeX, shakeY);
            
            // Clear canvas
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw parallax background
            drawParallaxBackground();
            
            drawParticles();
            drawBirdTrail();
            drawPipes();
            drawPowerups();
            drawObstacles();
            drawBird();
            
            // Draw magnet radius if active
            if (magnetRadius > 0) {
                ctx.strokeStyle = 'rgba(255, 204, 0, 0.2)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(bird.x, bird.y, magnetRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw combo multiplier
            if (comboMultiplier > 1.1) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(`${comboMultiplier.toFixed(1)}x COMBO!`, canvas.width / 2, 20);
            }
            
            ctx.restore();
        }

        function drawParallaxBackground() {
            parallaxLayers.forEach(layer => {
                const offset = layer.offset % layer.size;
                
                ctx.fillStyle = layer.color;
                for (let y = -layer.size; y < canvas.height + layer.size; y += layer.size) {
                    for (let x = -offset - layer.size; x < canvas.width + layer.size; x += layer.size) {
                        ctx.beginPath();
                        ctx.arc(x, y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }

        function drawBirdTrail() {
            if (bird.trail.length < 2) return;
            
            ctx.strokeStyle = bird.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bird.trail[0].x, bird.trail[0].y);
            
            for (let i = 1; i < bird.trail.length; i++) {
                ctx.lineTo(bird.trail[i].x, bird.trail[i].y);
            }
            
            ctx.stroke();
        }

        function drawBird() {
            // Draw bird body
            ctx.fillStyle = bird.color;
            ctx.beginPath();
            ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw wings
            ctx.save();
            ctx.translate(bird.x, bird.y);
            
            // Left wing
            ctx.rotate(-0.5 + bird.flapWing * 0.5);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-bird.radius * 1.5, 0);
            ctx.lineTo(-bird.radius * 1.2, bird.radius * 0.5);
            ctx.closePath();
            ctx.fill();
            
            // Right wing
            ctx.rotate(1.0 - bird.flapWing * 0.5);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-bird.radius * 1.5, 0);
            ctx.lineTo(-bird.radius * 1.2, -bird.radius * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Draw eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(
                bird.x + bird.radius * 0.4, 
                bird.y - bird.radius * 0.2, 
                bird.radius * 0.3, 
                0, 
                Math.PI * 2
            );
            ctx.fill();
            
            // Draw glow if powered up
            if (powerupActive) {
                ctx.shadowColor = POWERUPS[powerupType.toUpperCase()].color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(bird.x, bird.y, bird.radius + 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function drawPipes() {
            pipes.forEach(pipe => {
                // Skip drawing if invisible and not visible
                if (pipe.type === 'invisible' && !pipe.visible) return;
                
                // Top pipe
                const topGradient = ctx.createLinearGradient(
                    pipe.x, 0, 
                    pipe.x + pipe.width, 0
                );
                topGradient.addColorStop(0, pipe.color);
                topGradient.addColorStop(1, darkenColor(pipe.color, 20));
                
                ctx.fillStyle = topGradient;
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
                
                // Bottom pipe
                const bottomGradient = ctx.createLinearGradient(
                    pipe.x, canvas.height - pipe.bottomHeight, 
                    pipe.x + pipe.width, canvas.height - pipe.bottomHeight
                );
                bottomGradient.addColorStop(0, darkenColor(pipe.color, 20));
                bottomGradient.addColorStop(1, pipe.color);
                
                ctx.fillStyle = bottomGradient;
                ctx.fillRect(
                    pipe.x, 
                    canvas.height - pipe.bottomHeight, 
                    pipe.width, 
                    pipe.bottomHeight
                );
                
                // Pipe edges (neon effect)
                ctx.strokeStyle = lightenColor(pipe.color, 30);
                ctx.lineWidth = 3;
                
                // Top pipe edge
                ctx.beginPath();
                ctx.moveTo(pipe.x, pipe.topHeight);
                ctx.lineTo(pipe.x + pipe.width, pipe.topHeight);
                ctx.stroke();
                
                // Bottom pipe edge
                ctx.beginPath();
                ctx.moveTo(pipe.x, canvas.height - pipe.bottomHeight);
                ctx.lineTo(pipe.x + pipe.width, canvas.height - pipe.bottomHeight);
                ctx.stroke();
                
                // Pipe inner glow
                ctx.shadowColor = lightenColor(pipe.color, 30);
                ctx.shadowBlur = 10;
                ctx.strokeStyle = `${lightenColor(pipe.color, 30)}80`;
                ctx.lineWidth = 1;
                
                // Top pipe inner edge
                ctx.beginPath();
                ctx.moveTo(pipe.x + 5, pipe.topHeight - 2);
                ctx.lineTo(pipe.x + pipe.width - 5, pipe.topHeight - 2);
                ctx.stroke();
                
                // Bottom pipe inner edge
                ctx.beginPath();
                ctx.moveTo(pipe.x + 5, canvas.height - pipe.bottomHeight + 2);
                ctx.lineTo(pipe.x + pipe.width - 5, canvas.height - pipe.bottomHeight + 2);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                
                // Special pipe features
                switch(pipe.type) {
                    case 'spiky':
                        if (pipe.spikeTimer > pipe.spikeInterval - 500) {
                            // Draw spikes
                            ctx.fillStyle = '#ff0000';
                            const spikeCount = 5;
                            const spikeWidth = pipe.width / (spikeCount * 2);
                            
                            // Top spikes
                            for (let i = 0; i < spikeCount; i++) {
                                ctx.beginPath();
                                ctx.moveTo(pipe.x + i * (pipe.width / spikeCount), pipe.topHeight);
                                ctx.lineTo(pipe.x + i * (pipe.width / spikeCount) + spikeWidth, pipe.topHeight - 15);
                                ctx.lineTo(pipe.x + (i + 1) * (pipe.width / spikeCount), pipe.topHeight);
                                ctx.fill();
                            }
                            
                            // Bottom spikes
                            for (let i = 0; i < spikeCount; i++) {
                                ctx.beginPath();
                                ctx.moveTo(pipe.x + i * (pipe.width / spikeCount), canvas.height - pipe.bottomHeight);
                                ctx.lineTo(pipe.x + i * (pipe.width / spikeCount) + spikeWidth, canvas.height - pipe.bottomHeight + 15);
                                ctx.lineTo(pipe.x + (i + 1) * (pipe.width / spikeCount), canvas.height - pipe.bottomHeight);
                                ctx.fill();
                            }
                        }
                        break;
                        
                    case 'laser_gap':
                        if (pipe.laserActive) {
                            const gapCenter = pipe.topHeight + 
                                (canvas.height - pipe.topHeight - pipe.bottomHeight) / 2;
                            const laserHeight = 12;
                            
                            // Laser beam in gap
                            const gradient = ctx.createLinearGradient(
                                pipe.x, gapCenter - laserHeight / 2,
                                pipe.x, gapCenter + laserHeight / 2
                            );
                            gradient.addColorStop(0, 'rgba(0, 255, 255, 0.1)');
                            gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.8)');
                            gradient.addColorStop(1, 'rgba(0, 255, 255, 0.1)');
                            
                            ctx.fillStyle = gradient;
                            ctx.fillRect(
                                pipe.x, 
                                gapCenter - laserHeight / 2, 
                                pipe.width, 
                                laserHeight
                            );
                            
                            // Laser glow
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 20;
                            ctx.fillRect(
                                pipe.x, 
                                gapCenter - laserHeight / 2, 
                                pipe.width, 
                                laserHeight
                            );
                            ctx.shadowBlur = 0;
                        }
                        break;
                        
                    case 'invisible':
                        if (pipe.visible) {
                            // Draw faint outline when visible
                            ctx.strokeStyle = `${pipe.color}80`;
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            
                            // Top pipe outline
                            ctx.strokeRect(pipe.x, 0, pipe.width, pipe.topHeight);
                            
                            // Bottom pipe outline
                            ctx.strokeRect(
                                pipe.x, 
                                canvas.height - pipe.bottomHeight, 
                                pipe.width, 
                                pipe.bottomHeight
                            );
                            
                            ctx.setLineDash([]);
                        }
                        break;
                }
            });
        }

        function drawPowerups() {
            powerups.forEach(powerup => {
                const powerupData = POWERUPS[powerup.type.toUpperCase()];
                const pulseRadius = powerup.radius + (powerup.pulse || 0);
                
                // Outer glow
                ctx.shadowColor = powerupData.color;
                ctx.shadowBlur = 15;
                
                // Powerup circle
                const gradient = ctx.createRadialGradient(
                    powerup.x, powerup.y, 0,
                    powerup.x, powerup.y, pulseRadius
                );
                gradient.addColorStop(0, powerupData.color);
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, pulseRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset shadow
                ctx.shadowBlur = 0;
                
                // Inner symbol
                ctx.fillStyle = '#fff';
                ctx.font = `${pulseRadius * 1.2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerupData.symbol, powerup.x, powerup.y);
            });
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                if (obstacle.type === 'shooting_laser') {
                    // Draw shooting laser
                    const gradient = ctx.createLinearGradient(
                        obstacle.x, obstacle.y,
                        obstacle.x + obstacle.width, obstacle.y
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.1)');
                    gradient.addColorStop(0.5, 'rgba(255, 0, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0.1)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Laser glow
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 20;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    ctx.shadowBlur = 0;
                    
                    // Laser ends
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(obstacle.x - 5, obstacle.y, 10, obstacle.height);
                    ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y, 10, obstacle.height);
                }
            });
        }

        function drawParticles() {
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life / 1000;
                
                if (particle.type === 'spark') {
                    // Draw spark particles as lines
                    ctx.strokeStyle = particle.color;
                    ctx.lineWidth = particle.radius;
                    ctx.beginPath();
                    ctx.moveTo(particle.x, particle.y);
                    ctx.lineTo(
                        particle.x - particle.vx * 2, 
                        particle.y - particle.vy * 2
                    );
                    ctx.stroke();
                } else {
                    // Regular round particles
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        // Helper functions
        function darkenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            
            return '#' + (
                0x1000000 +
                (R < 0 ? 0 : R) * 0x10000 +
                (G < 0 ? 0 : G) * 0x100 +
                (B < 0 ? 0 : B)
            ).toString(16).slice(1);
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            
            return '#' + (
                0x1000000 +
                (R > 255 ? 255 : R) * 0x10000 +
                (G > 255 ? 255 : G) * 0x100 +
                (B > 255 ? 255 : B)
            ).toString(16).slice(1);
        }

        // Game functions
        function flap() {
            if (!gameRunning) return;
            
            bird.velocity = isMobile ? -8 : -10;
            createParticles(bird.x, bird.y - bird.radius, 5, bird.color, 'spark');
            playSound(flapSound, 0.2);
        }

        function generatePipe() {
            // Get available pipe types based on unlocked types
            const availableTypes = [];
            const typeKeys = Object.keys(PIPE_TYPES);
            
            for (let i = 0; i < Math.min(pipeTypesUnlocked, typeKeys.length); i++) {
                availableTypes.push(PIPE_TYPES[typeKeys[i]]);
            }
            
            // Calculate total weight for probability distribution
            let totalWeight = 0;
            availableTypes.forEach(type => totalWeight += type.weight);
            
            // Select random pipe type based on weights
            let random = Math.random() * totalWeight;
            let selectedType = availableTypes[0];
            
            for (const type of availableTypes) {
                if (random < type.weight) {
                    selectedType = type;
                    break;
                }
                random -= type.weight;
            }
            
            // Generate the selected pipe type
            pipes.push(selectedType.generate());
        }

        function generateShootingLaser() {
            obstacles.push({
                x: canvas.width,
                y: 50 + Math.random() * (canvas.height - 100),
                width: 50 + Math.random() * 100,
                height: 5 + Math.random() * 5,
                type: 'shooting_laser',
                speedFactor: 2 + Math.random() * 2
            });
        }

        function generatePowerup() {
            // Calculate total weight for probability distribution
            let totalWeight = 0;
            for (const key in POWERUPS) {
                totalWeight += POWERUPS[key].weight;
            }
            
            // Select random powerup type based on weights
            let random = Math.random() * totalWeight;
            let selectedType = 'speed';
            
            for (const key in POWERUPS) {
                if (random < POWERUPS[key].weight) {
                    selectedType = POWERUPS[key].name;
                    break;
                }
                random -= POWERUPS[key].weight;
            }
            
            const powerupData = POWERUPS[selectedType.toUpperCase()];
            
            // Find safe Y position (not inside pipes)
            let safeY;
            let attempts = 0;
            const maxAttempts = 10;
            
            do {
                safeY = 50 + Math.random() * (canvas.height - 100);
                attempts++;
                
                let inPipe = false;
                for (const pipe of pipes) {
                    if (safeY < pipe.topHeight || safeY > canvas.height - pipe.bottomHeight) {
                        inPipe = true;
                        break;
                    }
                }
                
                if (!inPipe || attempts >= maxAttempts) break;
            } while (true);
            
            powerups.push({
                x: canvas.width,
                y: safeY,
                radius: 15,
                type: powerupData.name,
                color: powerupData.color,
                pulse: 0
            });
        }

        function activatePowerup(type) {
            const powerupData = POWERUPS[type.toUpperCase()];
            
            // If another powerup is active, deactivate it first
            if (powerupActive) {
                deactivatePowerup();
            }
            
            powerupActive = true;
            powerupType = type;
            powerupEndTime = performance.now() + powerupData.duration;
            
            // Apply powerup effect
            powerupData.effect();
            playSound(powerupSound, 0.3);
            
            // Update powerup indicator
            powerupIndicator.classList.remove('hidden');
            powerupIndicator.querySelector('div').style.setProperty('--powerup-color', powerupData.color);
            powerupIndicator.querySelector('span').textContent = powerupData.symbol;
            
            // Create particles
            createParticles(bird.x, bird.y, 30, powerupData.color);
            
            // Screen flash effect
            ctx.fillStyle = `${powerupData.color}40`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function deactivatePowerup() {
            const powerupData = POWERUPS[powerupType.toUpperCase()];
            powerupData.deactivate();
            
            powerupActive = false;
            powerupType = '';
            bird.color = '#00fffc';
            
            powerupIndicator.classList.add('hidden');
            
            // Create deactivation particles
            createParticles(bird.x, bird.y, 20, '#ff0000');
        }

        function increaseDifficulty() {
            baseGameSpeed += 0.05;
            gameSpeed = baseGameSpeed;
            if (powerupActive && powerupType === 'speed') {
                gameSpeed *= 1.5;
            }
            if (powerupActive && powerupType === 'godmode') {
                gameSpeed *= 3;
            }
            gravity += 0.2;
            pipeInterval = Math.max(400, pipeInterval - 3);
        }

        function createParticles(x, y, count, color, type = 'round') {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    radius: type === 'spark' ? 1 + Math.random() * 2 : 2 + Math.random() * 3,
                    vx: -2 + Math.random() * 4,
                    vy: -2 + Math.random() * 4,
                    life: 300 + Math.random() * 700,
                    color: color,
                    type: type
                });
            }
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            
            createParticles(bird.x, bird.y, 50, '#ff0000');
            playSound(gameOverSound, 0.4);
            bgMusic.pause();
            
            if (score > hiScore) {
                hiScore = score;
                localStorage.setItem('neonFlareHiScore', hiScore);
            }
            
            finalScore.textContent = Math.floor(score);
            highScore.textContent = Math.floor(hiScore);
            gameOverScreen.classList.remove('hidden');
            gameUI.classList.add('hidden');
        }

        // Event listeners
        startButton.addEventListener('click', () => {
            playSound(buttonSound, 0.3);
            initGame();
        });
        
        restartButton.addEventListener('click', () => {
            playSound(buttonSound, 0.3);
            initGame();
        });
        
        menuButton.addEventListener('click', () => {
            playSound(buttonSound, 0.3);
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            bgMusic.pause();
        });
        
        // Volume control toggle
        volumeControl.addEventListener('click', (e) => {
            e.stopPropagation();
            playSound(buttonSound, 0.3);
            volumeSlider.classList.toggle('show');
        });
        
        // Close volume control when clicking outside
        document.addEventListener('click', () => {
            volumeSlider.classList.remove('show');
        });
        
        // Prevent volume slider clicks from closing it
        volumeSlider.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Control methods
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                flap();
            }
        });
        
        // Touch/click controls
        canvas.addEventListener('mousedown', flap);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            flap();
        });
        
        // Prevent scrolling on touch devices
        document.body.addEventListener('touchmove', (e) => {
            if (gameRunning) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Initial draw
        draw();
    });
</script>
</body>
</html>
